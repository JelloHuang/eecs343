Alex Zylman
Matthew Markwell


In this project we've implemented a simple file system on top of a virtual disk.  We chose to implement our disk using bitmaps.  The first sector of our disk is a bitmap, with each bit representing a sector on the disk.  The bit is set to 1 if the sector is in use, and is initialized to 0 (which means it is not in use).  The second sector of our disk is also a bitmap, this one representing the inodes in our file system.  Similarly, the bits are set to 1 for used inodes and 0 for free inodes.  The first inode is set to always be the root node.  Several other sectors at the beginning of the disk are then used to store all the inodes (we stored 2000 because we didn't know how many we should have and that is the theoretical maximum needed because that is the number of sectors on the virtual disk).
We used our inodes in two different ways.  If the inode represented a directory, it had a boolean field "isFile" which was set to zero.  It stores an array of integers that are the inode numbers of the subdirectories and files it contains.  It also stores the integer of the inode for its parent directory, so that it can access its parent.  The other way we used inodes is for files.  Files have the "isFile" field set to 1.  They store similar information as directories, except that the array of integers represent sector numbers, not inode numbers.  These sectors are the sectors that store the data for the file.  One design decision we made has to do with the arbitrary expansion of a file or arbitrary number of subdirectories and files in a directory.  Our array of ints in our inodes contains only 6 ints.  What we did to solve this problem is that we stored another integer called "cont" that represents another inode.  When all 6 spots are filled in the array, another inode is allocated and the int for this inode is stored in "cont".  If "cont" is not equal to -1, then the file or directory has more than 6 sectors/inodes in it.  This linked list design allows an arbitrarily big file size or an arbitrarily big amount of files and subdirectories in a directory. Dealing with memory issues was by far the greatest challenge in this assignment. Pointer arithmetic kept causing us problems as well. 
Over all, our design is very similar (though much simpler) to typical UNIX file systems. 
